# 数组与链表

数组: 内存中连续存放 
链表: 内存中不必连续存放，通过指针连接起来

数组元素访问方便  链表插入、删除方便

## 链表结构

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};
  ```

## 反转链表

非递归  每遍历一个结点就翻转

```cpp
ListNode* reverse(ListNode* head) {
    if(head == NULL || head->next == NULL) return head;
    ListNode* pHead = NULL;
    while(head) {
        ListNode* tmp = head->next;
        head->next = pHead;
        pHead = head;
        head = tmp;
    }
    return pHead;
}
```

递归

```cpp
ListNode* reverse(ListNode* head) {
    if(head == NULL || head->next == NULL) return head;
    ListNode* last = reverse(head->next);
    head->next->next = head;
    head->next = NULL;
    return last;
}
```

## 反转前K个结点

非递归
```cpp
ListNode* reverseFirstK(ListNode* head, int k) {
    if(head == NULL || head->next == NULL || k < 2) return head;
    ListNode* pHead = NULL;
    ListNode* node = head;
    while(node && k--) {
        ListNode* tmp = node->next;
        node->next = pHead;
        pHead = node;
        node = tmp;
    }
    head->next = node;
    return pHead;
}
```

递归 使用successor来记录翻转边界的后继节点

```cpp
ListNode* successor;
ListNode* reverseFirstK(ListNode* head, int k) {
   if(k == 1) {
       successor = head->next;
       return head;
   }
   ListNode* last = reverseFirstK(head->next, k - 1);
   head->next->next = head;
   head->next = successor;
   return last;
}
```

## 反转[m, n]的链表结点

递归
```cpp
ListNode* reverseBetween(ListNode* head, int m, int n) {
    if(m == 1) return reverseFirstK(head, n);
    head->next = reverseBetween(head->next, m - 1, n - 1);
    return head;
}

非递归
```cpp
ListNode* reverseBetween(ListNode* head, int m, int n) {
   if(head == NULL || head->next == NULL) return head;
   ListNode root(0);
   root.next = head;
   ListNode* p = &root;
   ListNode* q = &root;
   m--;
   while(m--) p = p->next; //m-1 结点
   while(n--) q = q->next; // n结点

   ListNode* tail = q->next;
   q->next = NULL;
   ListNode* cur = p->next;
   while(cur) {
       ListNode* tmp = cur->next;
       cur->next = tail;
       tail = cur;
       cur = tmp;
   }
   p->next = tail;
   return root.next;
}
```

## K个一组反转链表

```cpp
ListNode* reverseKGroup(ListNode* head, int k) {
    if(head == NULL || head->next == NULL || k < 2) return head;
    ListNode* temp = head;
    for(int i = 0; i < k; i++) {
        if(temp == NULL) return head;
        temp = temp->next;
    }
    ListNode* last = reverseFirstK(head, k);
    head->next = reverseKGroup(head->next, k);
    return last;
}
```