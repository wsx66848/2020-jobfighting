1. 一个int函数在内存的分布是怎么样的？
  int 4字节 **默认低位在前，高位在后**  3在内存中的分配是 00000011 00000000
2. ++i 与 i++有什么区别？在汇编层面区别
   理论上++i更快
   i++ 返回是一个int数据本身
   ++i 返回的是引用，可以作为左值
   ```c++
   int operator++(int) { int temp = *this; ++*this; return temp}
   int& operator() {*this += 1; return *this;}
   ```
3. int* 与 int** 区别
4. memcpy 与 memmove区别
   两个函数的作用都是将src指向的内存的n个字节拷贝到dst指向的内存中，区别在于src和dst指向的内存有重叠时，memcpy不会去检测是否重叠内存，它假定了内存不重叠，会出现覆盖的情况。但是memmove会先检测内存是否重叠，如果重叠的话调整拷贝开始的位置(从尾部开始)  
   ![memcopy](..\\操作系统\\memcopy.PNG "memcopy")
   如上图所示，src在从头部拷贝时，第4,5个字节会被第1,2个字节覆盖，memcpy不会检测这种重叠，但是memmove会从尾部开始拷贝
   所以memcpy需要程序员自己保证内存没有重叠，速度较快

5. sizeof 与 strlen
   * sizeof 是运算符  strlen是函数
   * sizeof统计数据类型所占空间大小，strlen统计字符串长度(以'\0'结尾)
   ```cpp
   char *c="abcdef";
   char d[]="abcdef";
   char e[]={'a','b','c','d','e','f'};
   printf("%d%d/n",sizeof(c),strlen(c));
   printf("%d%d/n",sizeof(d),strlen(d));
   printf("%d%d/n",sizeof(e),strlen(e));
   /*
    输出的结果是:

    4 6 （char*是4个字节)
  
    7 6  sizeof会算上\0

    6 14  没有\0结束符，strlen返回结果不确定
   */
   ```
1. 程序的内存结构  
BSS段 存放程序中**未初始化**的变量的内存区域 在运行时改变值 根据初始化值时局部变量还是全局变量，分配到相对应的存储区内，否则会持续待在BSS中  
数据段 存放程序中**已初始化**的全局变量的一块内存区域  属于静态内存分配 static变量也存放于此(staic inline const)  
**静态存储区在程序编译的时候已经分配好，在程序运行的过程中一直存在，存放静态数据、全局数据和常量**  
代码段 存放程序代码的一块内存区域  
文字常量区  常量字符串
堆   动态分配的内存区域 用户自己管理  
栈   存放程序的局部变量 编译器管理的 函数调用时用来传参和返回值  
![C程序内存](..\\操作系统\\C程序内存.jpg "C程序内存")
1. 在函数里面分配大数组会发生什么错误？这个错误在运行时还是编译时产生？编译的时候会压栈么？
   * 编译的时候会压栈（汇编代码中） 实参从右向左计算并压栈
   * 分配大数组超过内存空间时会发生segment fault错误，定义局部变量数组时会默认初始化为0，所以局部数组会直接分配到栈内存中，超过栈空间大小时运行报错（实测编译不报错，可能是编译时无法估计）
2. 你觉得一个函数最多能为数组分配的空间有多大？
   一个线程的栈空间按2M计算，int数组长度最多520060
3.  tcp udp连接？accpet函数位于哪个阶段？connect函数位于哪个阶段？  
    accpet位于握手完成  connect位于收到SYN+ACK时
4.  中断都了解多少 说一下软中断？
5.  syscall的具体过程
6.  gdb 
7.  大量的tcp连接处于close_wait是什么原因？如果是应用程序的原因会是什么因素？  
    没有发送FIN报文
    没有调用close关闭连接/程序逻辑有问题，卡在了死循环
8.  哈希表解决冲突？ 优先扩展链表长度还是桶数
9.  询问的范围: 基础(编译原理、操作系统) 语言  网络 算法